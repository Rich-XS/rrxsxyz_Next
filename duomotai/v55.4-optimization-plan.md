# V55.4 TextContent 流式优化方案

## 核心改进思路

### 1. **使用 textContent 替代 innerHTML**

#### 当前问题（V55.2）
```javascript
// ❌ 每次都重新解析和重构 DOM
contentDiv.innerHTML = this.formatSpeechContent(content, role);
```

#### 优化方案（V55.4）
```javascript
// ✅ 方案A：纯文本追加（最安全）
if (!contentDiv.dataset.initialized) {
    contentDiv.textContent = '';  // 初次清空
    contentDiv.dataset.initialized = 'true';
}

// 增量追加新内容
const lastLength = parseInt(contentDiv.dataset.lastLength || '0');
const newContent = content.substring(lastLength);
if (newContent) {
    contentDiv.textContent += newContent;
    contentDiv.dataset.lastLength = content.length;
}
```

### 2. **分离格式化逻辑**

不在实时流式输出时处理格式化，而是：
- **流式阶段**：纯文本快速显示
- **完成阶段**：一次性格式化

```javascript
handleRoleSpeak(event) {
    const { role, content, isComplete, isStreaming } = event.detail;

    if (isStreaming) {
        // 流式阶段：快速文本追加
        this.streamTextToCard(role, content);
    }

    if (isComplete) {
        // 完成阶段：格式化处理
        this.finalizeCard(role, content);
    }
}

streamTextToCard(role, content) {
    const contentDiv = card.querySelector('.speech-content');

    // 使用 textContent 而非 innerHTML
    if (!contentDiv.dataset.streamStarted) {
        contentDiv.textContent = '';
        contentDiv.dataset.streamStarted = 'true';
    }

    // 计算增量
    const currentLength = contentDiv.textContent.length;
    const newText = content.substring(currentLength);

    if (newText) {
        // 方式1：直接追加
        contentDiv.textContent += newText;

        // 方式2：创建文本节点（更精细控制）
        // const textNode = document.createTextNode(newText);
        // contentDiv.appendChild(textNode);
    }
}
```

### 3. **性能优化 - 节流更新**

避免每个 chunk 都触发 DOM 更新：

```javascript
class StreamBuffer {
    constructor(updateInterval = 50) {  // 20fps
        this.buffer = '';
        this.timer = null;
        this.updateInterval = updateInterval;
        this.targetElement = null;
    }

    append(text, element) {
        this.buffer += text;
        this.targetElement = element;

        if (!this.timer) {
            this.timer = setTimeout(() => {
                this.flush();
            }, this.updateInterval);
        }
    }

    flush() {
        if (this.targetElement && this.buffer) {
            this.targetElement.textContent += this.buffer;
            this.buffer = '';
        }
        this.timer = null;
    }
}

// 使用示例
const streamBuffers = new Map();  // role -> StreamBuffer

handleRoleSpeak(event) {
    const { role, content, isStreaming } = event.detail;

    if (isStreaming) {
        if (!streamBuffers.has(role)) {
            streamBuffers.set(role, new StreamBuffer());
        }

        const buffer = streamBuffers.get(role);
        const contentDiv = card.querySelector('.speech-content');

        // 计算增量
        const currentLength = contentDiv.textContent.length;
        const newText = content.substring(currentLength);

        // 缓冲追加
        buffer.append(newText, contentDiv);
    }
}
```

### 4. **TextRateController 集成**

利用现有的 `TextRateController` 控制显示速度：

```javascript
// src/modules/textRateController.js 已经有速率控制
// 集成到流式显示中

async displayTextWithRate(text, element) {
    const controller = window.TextRateController;
    const delayMs = controller.getCurrentDelay();

    if (delayMs === 0) {
        // 即时显示
        element.textContent += text;
        return;
    }

    // 逐字显示
    for (let char of text) {
        element.textContent += char;
        await new Promise(r => setTimeout(r, delayMs));
    }
}
```

## 实施步骤

### Step 1: 修改 debate-ui.js (第116-134行)
```javascript
// 替换 handleRoleSpeak 方法
handleRoleSpeak(event) {
    const { role, content, isComplete, isStreaming, round } = event.detail;

    // 创建或获取卡片
    let card = document.querySelector(`#speech-${role}-${round}`);
    if (!card) {
        card = this.createSpeechCard(role, round);
    }

    const contentDiv = card.querySelector('.speech-content');

    if (isStreaming) {
        // ✅ V55.4: 使用 textContent 流式追加
        if (!contentDiv.dataset.streamStarted) {
            contentDiv.textContent = '';  // 初始化
            contentDiv.dataset.streamStarted = 'true';
            contentDiv.dataset.lastLength = '0';
        }

        // 计算并追加增量内容
        const lastLength = parseInt(contentDiv.dataset.lastLength || '0');
        const newContent = content.substring(lastLength);

        if (newContent) {
            // 纯文本追加，避免 DOM 重构
            contentDiv.textContent += newContent;
            contentDiv.dataset.lastLength = content.length;

            // 平滑滚动到最新内容
            card.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }
    }

    if (isComplete) {
        // 完成时的最终处理
        card.classList.add('speech-complete');
        this.triggerVoiceOutput(content, role);

        // 可选：完成后进行一次格式化
        // this.applyFinalFormatting(contentDiv, content, role);
    }
}
```

### Step 2: 创建测试前检查清单
```markdown
## Pre-Test Checklist (V55.4)

### 代码检查
- [ ] 确认所有 innerHTML 替换为 textContent
- [ ] 确认增量计算逻辑正确（substring）
- [ ] 确认 dataset 属性初始化
- [ ] 语法检查：`node -c debate-ui.js`

### 版本号更新
- [ ] index.html 第12行：V55.4
- [ ] index.html 第144行：V55.4
- [ ] 更新说明：TextContent 流式优化

### 测试步骤
1. [ ] 强制刷新浏览器（Ctrl+F5）
2. [ ] 打开 Console 查看错误
3. [ ] 启动辩论流程
4. [ ] 观察文字流式输出
5. [ ] 验证无 DOM 闪烁
6. [ ] 验证滚动位置保持

### Gemba-Agent 自动化
```bash
node scripts/gemba-agent.js --scenario textcontent-v55.4
```
```

## 风险评估

### 潜在问题
1. **格式丢失**：textContent 不支持 HTML 格式
   - 缓解：完成后一次性格式化

2. **特殊字符**：某些字符可能显示异常
   - 缓解：使用 createTextNode 方法

3. **性能问题**：频繁 DOM 操作
   - 缓解：使用缓冲区节流更新

### 回滚方案
如果 V55.4 失败：
1. 立即回滚到 V55.2
2. 保存错误日志
3. 分析 Console 错误
4. 调整实现方案

## 预期效果

### 性能提升
- DOM 重构：N次 → 0次
- 更新复杂度：O(n²) → O(n)
- 用户体验：流畅、无闪烁

### 安全性提升
- 避免 XSS 风险（textContent 自动转义）
- 避免意外的 HTML 注入

### 可维护性
- 代码更简洁清晰
- 逻辑分离（流式 vs 格式化）
- 易于调试和测试