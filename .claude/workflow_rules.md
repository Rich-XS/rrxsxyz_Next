# Workflow Rules & Best Practices

工作流规范与最佳实践指南

---

## 任务完成后显示下五个任务

**规则说明：**
每次任务完成，准备进入下一个任务前，必须在屏幕显示接下来的五个任务列表。

**显示格式：**
```
📋 接下来的 5 个任务：

1. [优先级] 任务名称 - 预计工作量（简要说明）
2. [优先级] 任务名称 - 预计工作量（简要说明）
3. [优先级] 任务名称 - 预计工作量（简要说明）
4. [优先级] 任务名称 - 预计工作量（简要说明）
5. [优先级] 任务名称 - 预计工作量（简要说明）

当前批次: Batch X | 总进度: Y%
```

**实施要求：**
- **触发时机**：在每个任务标记为 ✅ COMPLETE 后立即显示
- **任务来源优先级**：
  1. `progress.md` TODO 区块（优先级排序：P0 > P1 > P2 > P3）
  2. `ideas.md`（如存在）
  3. 架构文档中的计划任务
- **显示内容**：
  - 任务优先级（P0/P1/P2/P3）
  - 任务名称（简短描述）
  - 预计工作量（分钟/小时）
  - 简要说明（1句话）
- **进度指标**：
  - 当前批次编号（如 Batch 1/3）
  - 总体完成进度百分比（如 65%）

**注意事项：**
- 如果剩余任务少于5个，显示所有剩余任务
- 优先显示P0任务，然后P1，依此类推
- 工作量估算应来自任务描述或历史数据
- 进度百分比基于 TODO 区块中已完成任务数量

---

## 任务切换时自动显示进度图（T-310，2025-10-12）

**规则说明：**
在任务完成并准备切换到下一个任务时，自动显示"各阶段任务进程示意图"，提供可视化的项目进度总览。

**触发时机：**
- 每个任务标记为 ✅ COMPLETE 后
- 在显示"接下来的 5 个任务"之前
- 任务优先级：P0/P1 任务完成必须显示，P2/P3 任务可选

**执行命令：**
```bash
node scripts/show_progress_chart.js
```

**显示格式示例：**
```
📊 项目进度总览：

阶段一: |xxx|xxxxx|xxxxxx|xxxx|xx|              (任务#: 5/5 100%; 工作量H: 20/20 100%)
阶段二: |xxx|xxxx|xx...|===|---|.......|    (任务#: 2/6  33%; 工作量H:  9/30  30%)
阶段三: |xx|x...|----|===|....|....|      (任务#: 1/7  14%; 工作量H:  1/20   5%)
阶段四: |...|....|....|....|....|....|....|     (任务#: 0/5   0%; 工作量H:  0/250  0%)

总体进度: 43.9% (25/57任务，56/300小时)

符号说明：
  x = 已完成
  = = 进行中（Sonnet-ONLY）
  . = 未开始（Sonnet/Haiku 均可）
  - = 未开始（Haiku 更适合）
```

**显示内容：**
- 4个阶段的任务进度条（任务块宽度反映预估工作量）
- 每阶段统计：任务数百分比、工作量小时百分比
- 总体进度：已完成任务数/总任务数、已完成工作量/总工作量
- 符号标注：根据任务复杂度和模型适配性分类
  - `x` - 已完成
  - `=` - 进行中或 Sonnet-ONLY 任务
  - `.` - 未开始，Sonnet/Haiku 均可
  - `-` - 未开始，Haiku 更适合

**实施要求：**
- 脚本位置：`scripts/show_progress_chart.js`（224行）
- 数据来源：硬编码项目数据（从 progress.md 提取）
- 输出方式：终端彩色文本（ANSI 颜色代码）
- 性能要求：执行时间 < 1秒

**注意事项：**
- 进度图在"接下来的 5 个任务"列表之前显示
- 如果脚本执行失败，记录错误但不阻塞任务切换流程
- 进度数据需要定期更新（每完成 5 个任务或每周更新一次）

---

## 50行输出原则（D-117，2025-11-04）

**核心原则**：所有响应必须控制在50行以内（不含工具调用），保持简洁高效

**根因分析（RCCM）**：
- **根因**：Night-Auth模式下过度详细说明，缺少输出自检机制，导致响应冗长（150行违规案例）
- **短期对策**：立即采用简洁输出，删除重复信息和冗余说明
- **长期对策**：建立输出预检清单，每次响应前自检行数和信息密度

**强制执行规则**：
1. ✅ **响应行数 ≤ 50行**（不含工具调用，仅计算输出文本）
2. ✅ **信息密度优先**：删除重复说明、冗余示例、已知信息
3. ✅ **引用而非复述**：指向文档位置，不重复文档内容
4. ✅ **输出预检清单**：响应前自检是否超行、是否有冗余

**正确示例**（10行以内）：
```
✅ 统一启动脚本已创建（3个文件）

📋 您现在需要做的（2步）：
1. 运行：powershell -ExecutionPolicy Bypass -File start.ps1
2. 选择：[3] 启动全栈

告诉我"已启动"，我运行Playwright测试。

详见：docs/STARTUP_GUIDE.md
```

**错误示例**（150行违规）：
```
❌ 重复说明启动方法3遍
❌ 列出完整文件内容（应该只列文件名+行号）
❌ 重复已知的D-79/D-68规则（应该只引用）
❌ 详细解释每个选项（应该只列核心步骤）
```

**例外情况**：
- RCCM完整分析：允许最多100行（但仍需精简）
- PRD文档生成：不受限制（创建新文档）
- 代码审查报告：允许最多80行

**成本考虑**（关联 cost_optimization.md）：
- 输出Token成本是输入的5倍（$15 vs $3/1M）
- 150行响应约3000 tokens ≈ $0.045
- 10行响应约200 tokens ≈ $0.003（节省93%成本）

**关联决策**：
- D-117 (2025-11-04) - 50行输出原则（RCCM完成）
- 符合 D-53 三层决策落实机制（Layer 1-2-3 同步完成）

---

## Auto-Compact 最佳实践与 Chatlog 管理

**背景说明**：
Claude Code 的 context auto-compact 是系统层面的上下文管理机制，当对话上下文接近限制时自动压缩历史记录。由于这是系统级行为，无法通过代码直接 hook 或自动触发 >>chatlog。

**⚠️ 技术限制**：
- ❌ 无法监听 auto-compact 事件（系统级，无 API 暴露）
- ❌ 无法在 auto-compact 时自动执行 >>chatlog（无钩子函数）
- ✅ 可以通过最佳实践手动触发，确保重要记录不丢失

**📋 最佳实践 - 何时手动触发 >>chatlog**：

1. **重要里程碑完成后**（强烈建议）：
   - 完成 P0/P1 核心任务后
   - 完成重要架构调整后
   - 完成关键决策讨论后

2. **对话即将压缩前**（预防性保存）：
   - 当看到"Token usage: X/200000"接近 180000 时
   - 当对话轮次超过 50 轮时
   - 当讨论跨越多个技术细节时

3. **会话即将结束前**（必须执行）：
   - 用户说">>wrap-up"或"准备关机"时
   - Night-Auth 协议即将到期前（如当前 16:00）
   - 长时间会话（如超过 2 小时）结束前

**💡 手动触发方法**：
```
用户输入: >>chatlog
系统行为: progress-recorder agent 自动保存当前会话到 chatlogs/chatlog_YYYYMMDDHHmm_<主题>.md
```

---

## 自动 Chatlog 触发机制（#116 任务，2025-10-10）

**核心需求**：当 chat window 的 token usage 接近 auto-compact 临界值（95%，约 190,000/200,000 tokens）时，自动提示用户触发 >>chatlog 保存当前会话记录，防止重要对话记录丢失。

**⚠️ Claude Code 必须遵守的自动检测规则**：

1. **Level 1 警告（90% 阈值）- 当 Token usage ≥ 180,000**：
   - 在响应末尾添加提醒：
     ```
     ⚠️ **Token 使用提醒**：当前会话已使用 X tokens (90%+)，建议尽快触发 `>>chatlog` 保存重要记录。
     ```

2. **Level 2 强烈建议（95% 阈值）- 当 Token usage ≥ 190,000**：
   - 在响应开头添加醒目提示：
     ```
     🚨 **紧急提醒**：Token 使用已达 X tokens (95%+)，即将触发 auto-compact！
     **强烈建议立即执行 `>>chatlog` 保存当前会话**，否则可能丢失重要对话记录。
     ```
   - 如果用户正在执行 P0/P1 任务，在任务完成后自动提示：
     ```
     ✅ 任务 #XXX 已完成。
     🚨 检测到 Token 使用接近上限（X tokens），建议立即执行 `>>chatlog` 保存本次会话记录。
     ```

3. **自动触发时机（主动建议）**：
   - **P0/P1 任务完成后**：如果 Token usage > 150,000，主动提示用户触发 >>chatlog
   - **重要架构调整后**：如果 Token usage > 150,000，主动提示
   - **会话时长超过 2 小时**：主动建议触发 >>chatlog
   - **对话轮次超过 50 轮**：主动建议触发 >>chatlog

4. **检测方法**：
   - Claude Code 在每次响应时，可以从系统提示 `<system_warning>Token usage: X/200000; Y remaining</system_warning>` 中读取当前 token 使用量
   - 无需额外工具或脚本，仅需在响应时主动检查这个系统级信息

**❌ 禁止行为**：
- 忘记检查 token usage（每次响应都应检查）
- Token 超过 95% 时仍未提示用户（必须提示）
- 在关键任务完成后未主动建议触发 >>chatlog（如 Token > 150,000）

**✅ 最佳实践**：
- 每次响应时主动检查 token usage
- 根据阈值给出相应级别的提示
- 在 P0/P1 任务完成后主动建议保存会话记录
- 保持提示简洁清晰，不干扰正常工作流程

---

## Token 使用优化建议

**预算目标**: $20/天，峰值不超过 $50/天

**Token 使用优化**:
- 避免频繁读取大文件（超过 1000 行的文件分批读取）
- 优先使用 Grep/Glob 工具而非全文读取
- Night-Auth 期间减少屏幕输出，降低上下文占用
- 定期触发 >>chatlog 保存关键记录，压缩后可安全清理上下文

**📊 Token 使用监控**：
- **当前会话**: 每次工具调用后检查"Token usage"系统提示
- **累计统计**: 通过 progress.md Notes 区记录每日 token 消耗
- **成本估算**: Claude Sonnet 约 $3/1M input tokens, $15/1M output tokens
- **示例**: 一次完整辩论（10轮）约消耗 5000 tokens ≈ $0.075

**❌ 禁止行为**：
- 在 auto-compact 前忘记保存重要对话记录
- 频繁读取超大文件（如完整 progress.md 多次读取）
- 在无需要时过度使用 AI 模型（应优先使用本地计算）

**✅ 推荐工作流**：
```
1. 开始重要任务 → 2. 完成任务 → 3. 触发 >>chatlog（保存记录）
→ 4. 检查 Token usage → 5. 如接近限制，触发 >>archive（压缩历史）
```

---

## 模块化验证流程（D-73 决策，2025-10-17）

**目的**：防止"修复A时破坏B"的回归问题，通过模块化验证和增量备份提供精确的版本追踪和回溯能力。

### 6大模块划分

| 模块编号 | 模块名称 | 核心文件 | 验证重点 |
|---------|---------|---------|---------|
| Module 1 | 用户认证与数据验证 | userAuth.js, dataValidator.js | 登录流程、验证码、输入校验 |
| Module 2 | 角色与AI服务 | roles.js, aiCaller.js, promptAgent.js | 角色加载、AI调用、提示词生成 |
| Module 3 | 辩论引擎核心 | debateEngine.js | 辩论流程、轮次控制、状态管理 |
| Module 4 | 语音系统 | voice.js, voiceQueue.js | TTS输出、ASR输入、队列管理 |
| Module 5 | 报告生成与导出 | reportGenerator.js, emailService.js | 报告生成、邮件发送、PDF导出 |
| Module 6 | 前端UI与交互 | index.html, styles.css, main.js | UI渲染、用户交互、响应式布局 |

### 验证流程

**每个模块的验证步骤**：
1. **单元测试**：运行该模块的单元测试用例（如存在）
2. **集成测试**：验证该模块与相关模块的集成
3. **E2E测试**：执行涉及该模块的端到端测试场景
4. **手动验证**：人工检查关键功能点
5. **创建备份**：验证通过后立即创建模块级别的版本备份

**验证通过标准**：
- ✅ 所有自动化测试通过（如存在）
- ✅ 手动验证关键功能点无问题
- ✅ 无P0/P1级别的Bug或回归问题

### 增量备份机制

**备份触发时机**：每个模块验证通过后立即执行

**备份命名规范**：
```
rrxsxyz_next_YYYYMMDDHHmm_Module<N>_<模块名>.zip
```

**示例**：
- `rrxsxyz_next_202510172100_Module1_UserAuth.zip`
- `rrxsxyz_next_202510172130_Module2_AIService.zip`
- `rrxsxyz_next_202510172200_Module3_DebateEngine.zip`

**执行命令**（使用专用脚本）：
```powershell
# 使用 ModuleBackup.ps1（待开发）
PowerShell -NoProfile -ExecutionPolicy Bypass -File "scripts/ModuleBackup.ps1" -ModuleNumber 1 -ModuleName "UserAuth" -Execute

# 或使用现有脚本（临时方案）
PowerShell -NoProfile -ExecutionPolicy Bypass -File "scripts/TaskDone_BackUp_Exclude.ps1" -Keyword "Module1_UserAuth" -Execute
```

### 追踪文档（MODULE_VERIFICATION_LOG.md）

**文件位置**：项目根目录 `MODULE_VERIFICATION_LOG.md`

**内容结构**：
```markdown
# 模块化验证日志

| 模块编号 | 模块名称 | 验证状态 | 验证时间 | 备份版本 | 备份路径 | 验证人 |
|---------|---------|---------|---------|---------|---------|--------|
| Module 1 | 用户认证与数据验证 | ✅ 通过 | 2025-10-17 21:00 | 202510172100 | backups/...zip | Claude |
| Module 2 | 角色与AI服务 | ⏳ 进行中 | - | - | - | - |
| Module 3 | 辩论引擎核心 | ⬜ 未开始 | - | - | - | - |
| Module 4 | 语音系统 | ⬜ 未开始 | - | - | - | - |
| Module 5 | 报告生成与导出 | ⬜ 未开始 | - | - | - | - |
| Module 6 | 前端UI与交互 | ⬜ 未开始 | - | - | - | - |

**验证问题记录**：
- [Module X] 问题描述 → 解决方案 → 验证结果
```

### 回归保障机制

**问题发生时**：
1. 识别受影响的模块（如"修复Module 3导致Module 4出问题"）
2. 从对应模块的稳定版本备份恢复（如恢复Module 4的最后一次通过验证的备份）
3. 重新验证修复后的Module 3
4. 重新验证受影响的Module 4

**优势**：
- ✅ 精确定位问题模块
- ✅ 快速回滚到稳定版本（无需完整项目回滚）
- ✅ 减少回归问题的影响范围
- ✅ 提升最终交付质量和信心

### 实施注意事项

1. **顺序验证**：建议按照模块编号顺序验证（Module 1 → Module 6），因为存在依赖关系
2. **独立备份**：每个模块的备份独立保存，避免备份文件过大
3. **日志更新**：每次验证后立即更新 MODULE_VERIFICATION_LOG.md
4. **问题记录**：遇到问题时详细记录到日志中，包括问题描述、解决方案、验证结果

---

## 决策同步检查表（D-53 决策，2025-10-12）

**目的**：确保每个重要决策在 3 个层级同步，防止决策记录与执行脱节

**📋 决策同步 Checklist**：

### 决策前（确认阶段）
- [ ] 明确决策类型（规则变更/架构调整/工作流优化/成本策略/Agent 行为）
- [ ] 确认触发关键词（` !规则变更` / ` !架构调整` / ` !工作流优化` 等）
- [ ] 确定需要更新的层级（Layer 1 / Layer 2 / Layer 3）
- [ ] 评估优先级（P0 / P1 / P2）

### 决策记录（Layer 1）
- [ ] ✅ 调用 progress-recorder agent
- [ ] ✅ 记录到 progress.md Decisions 区块
- [ ] ✅ 包含决策编号、时间、类型、背景、内容、验证方式
- [ ] ✅ 标记同步状态（Layer 1/2/3 的 ✅ 状态）

### 文档更新（Layer 2）
- [ ] ✅ 根据决策类型更新对应文档：
  - **规则变更** → CLAUDE.md
  - **架构调整** → architecture_guide.md
  - **工作流优化** → workflow_rules.md
  - **成本策略** → cost_optimization.md
  - **Agent 行为** → agent_config.md
- [ ] ✅ 添加/更新时间戳：`**Last Updated**: YYYY-MM-DD HH:MM`
- [ ] ✅ 添加决策引用：`（D-XX 决策，YYYY-MM-DD）`

### Agent 配置更新（Layer 3）
- [ ] ✅ 仅 P0 决策需要更新 agent 配置
- [ ] ✅ 更新 `.claude/agents/*.md` 文件（如适用）
- [ ] ✅ 添加新规则到 agent 配置中
- [ ] ✅ 确保规则可执行（包含触发条件、执行步骤、输出格式）

### 验证与审计
- [ ] ✅ 在 progress.md 中标记"✅ 3层同步完成"
- [ ] ✅ 列出更新的文件路径和行号
- [ ] ✅ 记录到审计日志 `.claude/audit.log`（如适用）
- [ ] ✅ 测试新规则是否生效（下次相关操作时验证）

---

## 决策同步快速参考

**关键词→文件映射表**（详见 CLAUDE.md）：

| 触发关键词 | Layer 2 文件 | Layer 3 文件 |
|-----------|-------------|-------------|
| ` !规则变更` / ` !请长期记忆` | CLAUDE.md | agent 配置 |
| ` !架构调整` / ` !重构` | architecture_guide.md | - |
| ` !工作流优化` | workflow_rules.md | agent 配置 |
| ` !成本优化` | cost_optimization.md | agent 配置 |
| ` !Agent更新` | agent_config.md | `.claude/agents/*.md` |

**执行流程速记**：
1. 决策确认 → 2. Layer 1 记录 → 3. Layer 2 文档 → 4. Layer 3 配置 → 5. 验证完成

---

**Last Updated**: 2025-10-17 21:00 (GMT+8) - 新增模块化验证流程（D-73 决策）
